//
//  NavigationViewController.swift
//  HYDD-driver
//
//  Created Macbook Pro on 11/04/2020.
//  Copyright Â© 2020 Syed Kashan. All rights reserved.
//
//  Template generated by Syed Kashan
//

import UIKit
import GoogleMaps

class NavigationViewController: BaseViewController, NavigationViewProtocol {
    
    @IBOutlet weak var buttonAddress: UIButton!
    @IBOutlet weak var viewPickup: RoundShadowView!
    @IBOutlet weak var labelPickup: UILabel!
    @IBOutlet weak var viewChatOpen: UIView!
    @IBOutlet weak var viewMap: GMSMapView!
    @IBOutlet weak var viewGo: RoundShadowView!
    @IBOutlet weak var buttonGo: UIButton!
    @IBOutlet weak var viewRemaining: UIView!
    @IBOutlet weak var lblLeftHours: UILabel!
    @IBOutlet weak var lblLeftKms: UILabel!
    @IBOutlet weak var labelKms: UILabel!
    @IBOutlet weak var labelHours: UILabel!
    @IBOutlet weak var lblSendMessage: UILabel!
    @IBOutlet weak var lblChat: UILabel!
    
    var previousCoordinates = CLLocationCoordinate2D()
    var presenter: NavigationPresenterProtocol?
    
    let camera = GMSCameraPosition()
    let markerCar = GMSMarker()
    let markerPickup = GMSMarker()
    var missionTimer: Timer?
    
    override func viewDidLoad() {
        super.viewDidLoad()
        labelKms.setLabelFeatures(text: DJM.shared.getValue(view: "status_cell_views", variable: "total_kms"), font: "Gibson-Regular", size: 15)
             labelHours.setLabelFeatures(text: DJM.shared.getValue(view: "status_cell_views", variable: "total_hours"), font: "Gibson-Regular", size: 15)
            lblSendMessage.setLabelFeatures(text: DJM.shared.getValue(view: "status_cell_views", variable: "send_message"), font: "Gibson-Regular", size: 17)
             lblChat.setLabelFeatures(text: DJM.shared.getValue(view: "status_cell_views", variable: "chat_driver"), font: "Gibson-Regular", size: 15)
            lblSendMessage.textColor = UIColor.darkGray.withAlphaComponent(0.9)
            lblChat.textColor = UIColor.lightGray
        let ordertype = HDCM.shared.clientUserDetails?.orderName
        if ordertype == "As Directed" {
            viewRemaining.isHidden = false
            let (h, m, _) = secondsToHoursMinutesSeconds(seconds: (HDCM.shared.clientUserDetails?.rem_sec.integerValue ?? 0) )
             let leftKM = Double(HDCM.shared.clientUserDetails?.rem_km.integerValue ?? 0) / 1000
          //  lblLeftKms.attributedText = "\(Double(HDCM.shared.clientUserDetails?.rem_km.integerValue ?? 0) / 1000 )kms".styled(as: .gibsonRegular_24sp_white)
            if leftKM < 0 {
                               labelKms.setLabelFeatures(text: DJM.shared.getValue(view: "status_cell_views", variable: "extra_kms"), font: "Gibson-Regular", size: 15)
                               lblLeftKms.attributedText = "\(abs(leftKM.rounded(toPlaces: 1)))kms".styled(as: .gibsonRegular_24sp_white)
                               lblLeftHours.attributedText = "\(h)h\(m)m".styled(as: .gibsonRegular_24sp_white)
                       }else{
                           lblLeftKms.attributedText = "\(leftKM.rounded(toPlaces: 1))kms".styled(as: .gibsonRegular_24sp_white)
                           lblLeftHours.attributedText = "\(h)h\(m)m".styled(as: .gibsonRegular_24sp_white)
                       }
            
           // lblLeftHours.attributedText = "\(h)h\(m)".styled(as: .gibsonRegular_24sp_white)
            self.missionTimer = Timer.scheduledTimer(timeInterval: 10, target: self, selector: #selector(self.updateRemainingTimeNDistance), userInfo: nil, repeats: true)
        } else {
            viewRemaining.isHidden = true
            viewPickup.topConstraint?.constant = 0
        }
    }
    override func viewWillAppear(_ animated: Bool) {
        super.viewWillAppear(animated)
        NotificationCenter.default.addObserver(self, selector: #selector(showRemValues(_:)), name: Notification.Name("remainingValues"), object: nil)
        let (lat, long) = HLM.shared.getForLatLong()
        previousCoordinates = CLLocationCoordinate2D(latitude: lat, longitude: long)
        self.navigationController?.tabBarController?.tabBar.isHidden = true
        let swipeGesture = UISwipeGestureRecognizer(target: self, action: #selector(actionChat))
        swipeGesture.direction = .up
        viewChatOpen.addGestureRecognizer(swipeGesture)
        let tapGesture = UITapGestureRecognizer(target: self, action: #selector(actionChat))
        viewChatOpen.addGestureRecognizer(tapGesture)
        self.setupNavigation()
        self.setupView()
    }
    
    override func viewWillDisappear(_ animated: Bool) {
        super.viewWillDisappear(animated)
        self.navigationController?.tabBarController?.tabBar.isHidden = false
    }
    override func viewWillLayoutSubviews() {
        super.viewWillLayoutSubviews()
        DispatchQueue.main.async {
            self.viewChatOpen.roundCorners([.topLeft, .topRight], radius: 12)
        }
    }
    
    @IBAction func actionAddressSelect(_ sender: UIButton) {
        self.viewGo.isHidden = false
        guard let orderType = HDCM.shared.clientUserDetails?.orderName,
            let status = HDCM.shared.getStatus() else {return}
        if orderType == "As Directed" && status == .onBoardClient {
            GooglePlacePicker.shared.openPlacePicker()
            GooglePlacePicker.shared.completion = { addressDict in
                guard let dict = addressDict.dictionary else {return}
                DispatchQueue.main.async {
                    self.labelPickup.text = dict[AddressStrKey.address]!.stringValue
                    let para: [String: Any] = [AddressStrKey.address: dict[AddressStrKey.address]!.stringValue,
                                               AddressStrKey.lat: dict[AddressStrKey.lat]!.doubleValue,
                                               AddressStrKey.long: dict[AddressStrKey.long]!.doubleValue]
                    RDBM.shared.realm.beginWrite()
                    HDCM.shared.clientUserDetails?.destLat = para[AddressStrKey.lat] as? Double ?? 0.0
                    HDCM.shared.clientUserDetails?.destLong = para[AddressStrKey.long] as? Double ?? 0.0
                    HDCM.shared.clientUserDetails?.destinationLocation = para[AddressStrKey.address] as? String ?? ""
                    let (lat, long) = HLM.shared.getForLatLong()
                    let initialCordinates = CLLocationCoordinate2D(latitude: lat, longitude: long)
                    let destCordinates = CLLocationCoordinate2D(latitude: para[AddressStrKey.lat] as? Double ?? 0.0, longitude: para[AddressStrKey.long] as? Double ?? 0.0)
                    let source = CLLocation(latitude: lat, longitude: long)
                    let dest = CLLocation(latitude: para[AddressStrKey.lat] as? Double ?? 0.0, longitude: para[AddressStrKey.long] as? Double ?? 0.0)
                    GooglePlacePicker.getRoutes(source: source, destination: dest) { (polylineString) in
                        DispatchQueue.main.async {
                            self.viewMap.clear()
                            self.makePolyline(str: polylineString)
                            self.markerCar.icon = UIImage(named: "icon_marker_car")
                            self.markerCar.position = initialCordinates
                            self.markerCar.map = self.viewMap
                            self.markerPickup.icon = UIImage(named: "icon_destination")
                            self.markerPickup.position = destCordinates
                            self.markerPickup.map = self.viewMap
                            let bounds = GMSCoordinateBounds(coordinate: initialCordinates, coordinate: destCordinates)
                            self.viewMap.animate(with: GMSCameraUpdate.fit(bounds, withPadding: 80))
                        }
                    }
                }
            }
        }
    }
    
    @IBAction func actionCurrentLocation(_ sender: Any) {
        let (lat, long) = HLM.shared.getForLatLong()
        let initialCordinates = CLLocationCoordinate2D(latitude: lat, longitude: long)
        viewMap.animate(to: GMSCameraPosition(target: initialCordinates, zoom: 18))
    }
    
    @IBAction func actionAdd(_ sender: Any) {
        self.presenter?.addPressed()
    }
    
    @IBAction func actionGo(_ sender: UIButton) {
        let slider = SlideInPresentationManager()
        let controller = NavigationGooglePopup()
        slider.disableCompactHeight = true
        slider.direction = .bottom
        slider.yAxis = 0.7
        slider.height = 0.5
        controller.modalPresentationStyle = .custom
        controller.delegate = self
        controller.transitioningDelegate = slider
        self.present(controller, animated: true, completion: nil)
    }
    
    @IBAction func backButtonPressed(_ sender: UIButton) {
        guard let navigationVC = self.navigationController else { return }
        navigationVC.popViewController(animated: false)
        let controller = MyJobsRouter.createModule()
        navigationVC.pushViewController(controller, animated: true)
    }
}

extension NavigationViewController: SetupViewController {
    func setupNavigation() {
        self.setNavigationWithLogoAndBackButton().addTarget(self, action: #selector(backButtonPressed(_:)), for: .touchUpInside)
    }
    func setupView() {
        if let status = HDCM.shared.getStatus() {
            switch status {
            case .pending:
                break       
            case .confirm:
                break
            case .inProgress:
                viewForInProgress()
            case .waitingClient:
                viewForWaitingClient()
            case .onBoardClient:
                viewForOnBoard()
            case .dayCompleted:
                viewForInProgress()
            case .close:
                break
            case .cancel:
                break
            }
        }
    }
    func networkRequest() {
        
    }
    
    func makePolyline(str: String) {
        DispatchQueue.main.async {
            let path = GMSPath(fromEncodedPath: str)
            let polyline = GMSPolyline(path: path)
            polyline.strokeWidth = 3.0
            polyline.strokeColor = .hyddblue
            polyline.map = self.viewMap
        }
    }
}

extension NavigationViewController: HyddLocationProtocol {
    func didUpdateLocation(location: CLLocationCoordinate2D) {
        let angleDetected = angle(fromCoordinate: previousCoordinates, toCoordinate: location)
        previousCoordinates = location
        updateMarker(coordinates: location, degrees: CLLocationDegrees(angleDetected), duration: 4)
    }
    
    func updateMarker(coordinates: CLLocationCoordinate2D, degrees: CLLocationDegrees, duration: Double) {
        // Keep Rotation Short
        markerCar.groundAnchor = CGPoint(x: CGFloat(0.5), y: CGFloat(0.5))
        
        CATransaction.begin()
        CATransaction.setAnimationDuration(duration)
        markerCar.icon = UIImage(named: "icon_marker_car")
        markerCar.position = coordinates
        print(degrees)
        markerCar.rotation = degrees //* (180.0 / Double.pi)
        markerCar.map = viewMap
        viewMap.camera = GMSCameraPosition(target: coordinates, zoom: 18)
        CATransaction.commit()
        
    }
    func angle(fromCoordinate first: CLLocationCoordinate2D, toCoordinate second: CLLocationCoordinate2D) -> Float {
        let degree: Float = (Float(atan2(sin(second.longitude - first.longitude) * cos(second.latitude), cos(first.latitude) * sin(second.latitude) - sin(first.latitude) * cos(second.latitude) * cos(second.longitude - first.longitude))))
        let finaldegree = degree * 180 / .pi
        return (finaldegree >= 0) ? finaldegree : (360 + finaldegree)
    }
    
    @objc func updateRemainingTimeNDistance() {
        if HDCM.shared.isUpdatingKMHours() {
            let time = UserDefaults.standard.lastLocationUpdate ?? Date()
            let prevCoOrdinates = CLLocation(latitude: UserDefaults.standard.lastLatitude ?? 0.0, longitude: UserDefaults.standard.lastLongitude ?? 0.0)
            guard let currentLocation = HLM.shared.myCurrentLocation else { return }
            let distance = currentLocation.distance(from: prevCoOrdinates)
            let para = ["consumed_hours": time.getSeconds(),
                        "consumed_kms": Int(distance)] as [String: Any]
            printHydd("para is: \(para)")
            HDCM.shared.updateConsumedHoursNDistance(para: para) { (success) in
                if success {
                    UserDefaults.standard.lastLocationUpdate = Date()
                    UserDefaults.standard.lastLatitude = currentLocation.coordinate.latitude
                    UserDefaults.standard.lastLongitude = currentLocation.coordinate.longitude
                }
            }
        }
    }
}

extension NavigationViewController {
    @objc func actionChat() {
        let controller = ChatRouter.createModule()
        let nav = UINavigationController(rootViewController: controller)
        nav.modalPresentationStyle = .overFullScreen
        self.present(nav, animated: true, completion: nil)
    }
}

extension NavigationViewController: NavigationPopupDelegate {
    func actionDismiss() {
        dismiss(animated: true, completion: nil)
    }
    func actionNoShow() {
        self.showLoadingIndicator()
        HDCM.shared.clientNoShow { (isSuccess, message) in
            DispatchQueue.main.async {
                self.hideLoadingIndicator()
                if isSuccess {
                    self.viewForOnBoard()
                } else {
                    HMM.shared.showError(title: DJM.shared.getValue(view: "navigation_view", variable: "error"), message: message)
                }
            }
        }
    }
    func actionClose() {
        self.showLoadingIndicator()
        HDCM.shared.driverCloseMission { (isSuccess, message) in
            DispatchQueue.main.async {
                self.hideLoadingIndicator()
                if isSuccess {
                    self.missionTimer?.invalidate()
                    self.presenter?.gotoInProgress()
                    guard let id = HUM.shared.user?.id,
                        let client = HDCM.shared.clientUserDetails?.userId else {return}
                    APPCONSTANT.Chats.databaseChats.child("Chat_\(id)/\(client)").observe(.childAdded) { (snapshot) in
                        if var data = snapshot.value as? [String: Any] {
                            let childKey = snapshot.key
                            data["is_active"] = 0
                            APPCONSTANT.Chats.databaseChats.child("Chat_\(id)/\(client)").child(childKey).setValue(data)
                        }
                    }
                    APPCONSTANT.Chats.databaseChats.child("Chat_\(client)/\(id)").observe(.childAdded) { (snapshot) in
                        if var data = snapshot.value as? [String: Any] {
                            let childKey = snapshot.key
                            data["is_active"] = 0
                            APPCONSTANT.Chats.databaseChats.child("Chat_\(client)/\(id)").child(childKey).setValue(data)
                        }
                    }
                    HDCM.shared.removeClient()
                } else {
                    HMM.shared.showError(title:DJM.shared.getValue(view: "navigation_view", variable: "error"), message: message)
                }
            }
        }
    }
    
    func actionOnboard() {
        self.showLoadingIndicator()
        HDCM.shared.clienOnBoard { (isSuccess, message) in
            DispatchQueue.main.async {
                self.hideLoadingIndicator()
                if isSuccess {
                    self.viewForOnBoard()
                } else {
                    HMM.shared.showError(title: DJM.shared.getValue(view: "navigation_view", variable: "error"), message: message)
                }
            }
        }
    }
    func actionDayCompleted() {
        self.showLoadingIndicator()
        HDCM.shared.driverDayCompleted { (isSuccess, message) in
            DispatchQueue.main.async {
                self.hideLoadingIndicator()
                if isSuccess {
                    self.presenter?.gotoInProgress()
                } else {
                    HMM.shared.showError(title: DJM.shared.getValue(view: "navigation_view", variable: "error"), message: message)
                }
            }
        }
    }
    func actionWaiting() {
        self.showLoadingIndicator()
        HDCM.shared.driverWaiting { (isSuccess, message) in
            DispatchQueue.main.async {
                self.hideLoadingIndicator()
                if isSuccess {
                    (UserDefaults.standard.lastLatitude, UserDefaults.standard.lastLongitude) = HLM.shared.getForLatLong()
                    UserDefaults.standard.lastLocationUpdate = Date()
                } else {
                    HMM.shared.showError(title: DJM.shared.getValue(view: "navigation_view", variable: "error"), message: message)
                }
            }
        }
    }
}

extension NavigationViewController {
    func viewForInProgress() {
        self.labelPickup.attributedText = HDCM.shared.clientUserDetails?.pickupLocation.styled(as: .gibsonRegular_16sp)
        HLM.shared.delegate = self
        giveBtnCornerRadiusWithTheDarkBackGround(view: viewGo, btn: buttonGo)
        buttonGo.setAttributedTitle(DJM.shared.getValue(view: "navigation_view", variable: "go").styled(as: .helveticaRegular_16sp), for: .normal)
        guard let pickLat = HDCM.shared.clientUserDetails?.pickLat,
            let pickLong = HDCM.shared.clientUserDetails?.pickLong else {return}
        let (lat, long) = HLM.shared.getForLatLong()
        let initialCordinates = CLLocationCoordinate2D(latitude: lat, longitude: long)
        let pickupCordinates = CLLocationCoordinate2D(latitude: pickLat, longitude: pickLong)
        let source = CLLocation(latitude: lat, longitude: long)
        let dest = CLLocation(latitude: pickLat, longitude: pickLong)
        GooglePlacePicker.getRoutes(source: source, destination: dest) { (polylineString) in
            self.makePolyline(str: polylineString)
            DispatchQueue.main.async {
                self.markerCar.icon = UIImage(named: "icon_marker_car")
                self.markerCar.position = initialCordinates
                self.markerCar.map = self.viewMap
                self.markerPickup.icon = UIImage(named: "icon_marker_pickup")
                self.markerPickup.position = pickupCordinates
                self.markerPickup.map = self.viewMap
                let bounds = GMSCoordinateBounds(coordinate: initialCordinates, coordinate: pickupCordinates)
                self.viewMap.animate(with: GMSCameraUpdate.fit(bounds, withPadding: 80))
            }
        }
    }
    func viewForWaitingClient() {
        HLM.shared.delegate = self
        guard let pickLat = HDCM.shared.clientUserDetails?.pickLat,
            let pickLong = HDCM.shared.clientUserDetails?.pickLong else {return}
        let (lat, long) = HLM.shared.getForLatLong()
        let initialCordinates = CLLocationCoordinate2D(latitude: lat, longitude: long)
        let pickupCordinates = CLLocationCoordinate2D(latitude: pickLat, longitude: pickLong)
        self.markerCar.icon = UIImage(named: "icon_marker_car")
        self.markerCar.position = initialCordinates
        self.markerCar.map = self.viewMap
        self.markerPickup.icon = UIImage(named: "icon_marker_pickup")
        self.markerPickup.position = pickupCordinates
        self.markerPickup.map = self.viewMap
        let bounds = GMSCoordinateBounds(coordinate: initialCordinates, coordinate: pickupCordinates)
        self.viewMap.animate(with: GMSCameraUpdate.fit(bounds, withPadding: 80))
        
    }
    func viewForOnBoard() {
        self.viewGo.isHidden = false
        HLM.shared.delegate = self
        guard let orderType = HDCM.shared.clientUserDetails?.orderName else {return}
        if orderType == "Transfer" {
            giveBtnCornerRadiusWithTheDarkBackGround(view: viewGo, btn: buttonGo)
            buttonGo.setAttributedTitle(DJM.shared.getValue(view: "navigation_view", variable: "go").styled(as: .helveticaRegular_16sp), for: .normal)
            labelPickup.attributedText = HDCM.shared.clientUserDetails?.destinationLocation.styled(as: .gibsonRegular_16sp)
            guard let destLat = HDCM.shared.clientUserDetails?.destLat,
                let destLong = HDCM.shared.clientUserDetails?.destLong else {return}
            let (lat, long) = HLM.shared.getForLatLong()
            let initialCordinates = CLLocationCoordinate2D(latitude: lat, longitude: long)
            let destCordinates = CLLocationCoordinate2D(latitude: destLat, longitude: destLong)
            let source = CLLocation(latitude: lat, longitude: long)
            let dest = CLLocation(latitude: destLat, longitude: destLong)
            GooglePlacePicker.getRoutes(source: source, destination: dest) { (polylineString) in
                DispatchQueue.main.async {
                    self.viewMap.clear()
                    self.makePolyline(str: polylineString)
                    self.markerCar.icon = UIImage(named: "icon_marker_car")
                    self.markerCar.position = initialCordinates
                    self.markerCar.map = self.viewMap
                    self.markerPickup.icon = UIImage(named: "icon_destination")
                    self.markerPickup.position = destCordinates
                    self.markerPickup.map = self.viewMap
                    let bounds = GMSCoordinateBounds(coordinate: initialCordinates, coordinate: destCordinates)
                    self.viewMap.animate(with: GMSCameraUpdate.fit(bounds, withPadding: 80))
                }
            }
        } else if orderType == "As Directed" {
            if let address = HDCM.shared.clientUserDetails?.destinationLocation, address != "As directed" {
                self.labelPickup.attributedText = "\(address)".styled(as: .gibsonRegular_16sp)
            } else {
                self.labelPickup.attributedText = DJM.shared.getValue(view: "navigation_view", variable: "select").styled(as: .gibsonRegular_16sp)
            }
            let (lat, long) = HLM.shared.getForLatLong()
            let initialCordinates = CLLocationCoordinate2D(latitude: lat, longitude: long)
            self.viewMap.clear()
            self.markerCar.icon = UIImage(named: "icon_marker_car")
            self.markerCar.position = initialCordinates
            self.markerCar.map = self.viewMap
            self.viewMap.camera = GMSCameraPosition(target: initialCordinates, zoom: 15)
        }
    }
}

extension NavigationViewController: NavigationGoogleDelegate {
    func actionNavigateWithWaze() {
        if let status = HDCM.shared.getStatus() {
            switch status {
            case .pending:
                break
            case .confirm:
                break
            case .inProgress:
                guard let lat = HDCM.shared.clientUserDetails?.pickLat,
                    let long = HDCM.shared.clientUserDetails?.pickLong else {return}
                if (UIApplication.shared.canOpenURL(NSURL(string:"waze://")! as URL)) {
                    UIApplication.shared.open(NSURL(string:
                        "waze://?ll=\(lat),\(long)&navigate=yes")! as URL)
                } else {
                    UIApplication.shared.open(URL(string: "http://itunes.apple.com/us/app/id323229106")!, options: [:], completionHandler: nil)
                }
            case .waitingClient:
                break
            case .onBoardClient:
                
                guard let orderType = HDCM.shared.clientUserDetails?.orderName else {return}
                if orderType == "Transfer" {
                    guard let lat = HDCM.shared.clientUserDetails?.destLat,
                        let long = HDCM.shared.clientUserDetails?.destLong else {return}
                    if (UIApplication.shared.canOpenURL(NSURL(string:"waze://")! as URL)) {
                        UIApplication.shared.open(NSURL(string:
                            "waze://?ll=\(lat),\(long)&navigate=yes")! as URL)
                    } else {
                        UIApplication.shared.open(URL(string: "http://itunes.apple.com/us/app/id323229106")!, options: [:], completionHandler: nil)
                    }
                } else if orderType == "As Directed" {
                    guard let lat = HDCM.shared.clientUserDetails?.destLat,
                        let long = HDCM.shared.clientUserDetails?.destLong else {return}
                    if (UIApplication.shared.canOpenURL(NSURL(string:"waze://")! as URL)) {
                        UIApplication.shared.open(NSURL(string:
                            "waze://?ll=\(lat),\(long)&navigate=yes")! as URL)
                    } else {
                        UIApplication.shared.open(URL(string: "http://itunes.apple.com/us/app/id323229106")!, options: [:], completionHandler: nil)
                    }
                }
                
            case .dayCompleted:
                guard let lat = HDCM.shared.clientUserDetails?.pickLat,
                    let long = HDCM.shared.clientUserDetails?.pickLong else {return}
                if (UIApplication.shared.canOpenURL(NSURL(string:"waze://")! as URL)) {
                    UIApplication.shared.open(NSURL(string:
                        "waze://?ll=\(lat),\(long)&navigate=yes")! as URL)
                } else {
                    UIApplication.shared.open(URL(string: "http://itunes.apple.com/us/app/id323229106")!, options: [:], completionHandler: nil)
                }
            case .close:
                break
            case .cancel:
                break
            }
        }
    }
    
    func actionNavigate() {
        if let status = HDCM.shared.getStatus() {
            switch status {
            case .pending:
                break
            case .confirm:
                break
            case .inProgress:
                guard let lat = HDCM.shared.clientUserDetails?.pickLat,
                    let long = HDCM.shared.clientUserDetails?.pickLong else {return}
                if (UIApplication.shared.canOpenURL(NSURL(string:"comgooglemaps://")! as URL)) {
                    UIApplication.shared.open(NSURL(string:
                        "comgooglemaps://?saddr=&daddr=\(lat),\(long)&directionsmode=driving")! as URL)
                } else {
                    UIApplication.shared.open(URL(string: "http://maps.google.com/maps?q=loc:\(lat),\(long)&directionsmode=driving")!, options: [:], completionHandler: nil)
                }
            case .waitingClient:
                break
            case .onBoardClient:
                
                guard let orderType = HDCM.shared.clientUserDetails?.orderName else {return}
                if orderType == "Transfer" {
                    guard let lat = HDCM.shared.clientUserDetails?.destLat,
                        let long = HDCM.shared.clientUserDetails?.destLong else {return}
                    if (UIApplication.shared.canOpenURL(NSURL(string:"comgooglemaps://")! as URL)) {
                        UIApplication.shared.open(NSURL(string:
                            "comgooglemaps://?saddr=&daddr=\(lat),\(long)&directionsmode=driving")! as URL)
                    } else {
                        UIApplication.shared.open(URL(string: "http://maps.google.com/maps?q=loc:\(lat),\(long)&directionsmode=driving")!, options: [:], completionHandler: nil)
                    }
                } else if orderType == "As Directed" {
                    guard let lat = HDCM.shared.clientUserDetails?.destLat,
                        let long = HDCM.shared.clientUserDetails?.destLong else {return}
                    if (UIApplication.shared.canOpenURL(NSURL(string:"comgooglemaps://")! as URL)) {
                        UIApplication.shared.open(NSURL(string:
                            "comgooglemaps://?saddr=&daddr=\(lat),\(long)&directionsmode=driving")! as URL)
                        self.viewGo.isHidden = true
                    } else {
                        UIApplication.shared.open(URL(string: "http://maps.google.com/maps?q=loc:\(lat),\(long)&directionsmode=driving")!, options: [:], completionHandler: nil)
                    }
                }
                
            case .dayCompleted:
                guard let lat = HDCM.shared.clientUserDetails?.pickLat,
                    let long = HDCM.shared.clientUserDetails?.pickLong else {return}
                if (UIApplication.shared.canOpenURL(NSURL(string:"comgooglemaps://")! as URL)) {
                    UIApplication.shared.open(NSURL(string:
                        "comgooglemaps://?saddr=&daddr=\(lat),\(long)&directionsmode=driving")! as URL)
                    self.viewGo.isHidden = true
                } else {
                    UIApplication.shared.open(URL(string: "http://maps.google.com/maps?q=loc:\(lat),\(long)&directionsmode=driving")!, options: [:], completionHandler: nil)
                    //                    HMM.shared.showBottomInfo(title: "", message: "You can't use google maps")
                }
            case .close:
                break
            case .cancel:
                break
            }
        }
    }
}

extension NavigationViewController {
    @objc func showRemValues(_ notification: Notification) {
        
        guard let userInfo = notification.userInfo as NSDictionary?,
            let km = userInfo["km"] as? Int,
            let sec = userInfo["sec"] as? Int else {return}
        DispatchQueue.main.async {
            let leftKM = (Double(km) ) / 1000
         //   self.lblLeftKms.attributedText = "\(leftKM)kms".styled(as: .gibsonRegular_24sp_white)
            let (h, m, _) = self.secondsToHoursMinutesSeconds(seconds: Int(sec) )
          //  self.lblLeftHours.attributedText = "\(h)h\(m)".styled(as: .gibsonRegular_24sp_white)
            
            if leftKM < 0 {
                self.labelKms.setLabelFeatures(text: DJM.shared.getValue(view: "status_cell_views", variable: "extra_kms"), font: "Gibson-Regular", size: 15)
                self.lblLeftKms.attributedText = "\(abs(leftKM.rounded(toPlaces: 1)))kms".styled(as: .gibsonRegular_24sp_white)
                self.lblLeftHours.attributedText = "\(h)h\(m)m".styled(as: .gibsonRegular_24sp_white)
            }else{
                self.lblLeftKms.attributedText = "\(leftKM.rounded(toPlaces: 1))kms".styled(as: .gibsonRegular_24sp_white)
                self.lblLeftHours.attributedText = "\(h)h\(m)m".styled(as: .gibsonRegular_24sp_white)
            }
            
        }
    }
    
    func secondsToHoursMinutesSeconds (seconds : Int) -> (Int, Int, Int) {
        return (seconds / 3600, (seconds % 3600) / 60, (seconds % 3600) % 60)
    }
    
}
